#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble

\renewcommand{\vec}[1]{\mathbf{#1}}

\renewcommand{\labelenumi}{(\alph{enumi})}
\renewcommand{\labelenumii}{(\roman{enumii})}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\topmargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 2
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section*
18.335 Problem Set 2
\end_layout

\begin_layout Standard
Due Monday, 16 February 2015.
\end_layout

\begin_layout Subsection*
Problem 1: Floating point
\end_layout

\begin_layout Standard
Trefethen, probem 13.2.
 (For part 
\emph on
c
\emph default
, you can use Julia, which employs IEEE double precision by default.
 However, unlike Matlab, Julia distinguishes between integer and floating-point
 scalars.
 For example, 
\family typewriter
2^50
\family default
 in Julia will produce a 64-bit integer result; to get a 64-bit/double floating-
point result, do e.g.
 
\family typewriter
2.0^50
\family default
 instead.)
\end_layout

\begin_layout Subsection*
Problem 2: Quadratic blues
\end_layout

\begin_layout Standard
Suppose we are solving the quadratic equation 
\begin_inset Formula $x^{2}-2bx+c=0$
\end_inset

.
 The familiar quadratic formula gives the two solutions 
\begin_inset Formula $x_{\pm}=b\pm\sqrt{b^{2}-c}$
\end_inset

.
 Here, we will consider the accuracy of the 
\begin_inset Formula $x_{-}$
\end_inset

 root for 
\begin_inset Formula $|c|\ll b^{2}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Using the code from the pset1 Julia notebook posted on the web page, plot
 the accuracy of 
\begin_inset Formula $x_{-}=b-\sqrt{b^{2}-c}$
\end_inset

 for 
\begin_inset Formula $b=1$
\end_inset

 and for a range of 
\begin_inset Formula $c$
\end_inset

 values from 
\begin_inset Formula $10^{-1}$
\end_inset

 to 
\begin_inset Formula $10^{-20}$
\end_inset

.
 Explain the observed inaccuracy.
\end_layout

\begin_layout Enumerate
Propose an alternative way to compute 
\begin_inset Formula $x_{-}$
\end_inset

 that will yield accurate results (within a factor of 10 of machine precision)
 in double precision.
 Implement your method and plot its accuracy in Julia using a modified version
 of the code in the previous part.
\end_layout

\begin_layout Subsection*
Problem 3: Newtonish methods
\end_layout

\begin_layout Standard
Newton's method for a root of 
\begin_inset Formula $f(x)=0$
\end_inset

 is to iterate 
\begin_inset Formula $x_{n+1}=x_{n}-f(x_{n})/f'(x_{n})$
\end_inset

 starting from some initial guess 
\begin_inset Formula $x_{1}$
\end_inset

 (which must be sufficiently close to the root to guarantee convergence
 in general).
 Suppose that you are also given 
\begin_inset Formula $f''(x)$
\end_inset

, the second derivative.
 In this problem, you will propose an iteration scheme that takes advantage
 of this second-derivative information.
\end_layout

\begin_layout Enumerate
Propose a Newton-like iteration that takes advantage of 
\begin_inset Formula $f$
\end_inset

, 
\begin_inset Formula $f'$
\end_inset

, and 
\begin_inset Formula $f''$
\end_inset

 (assuming 
\begin_inset Formula $f$
\end_inset

 is analytic in the neighborhood of the root).
 (Hint: use a second-order Taylor approximation of 
\begin_inset Formula $f$
\end_inset

.) If you solve a quadratic equation, make sure you avoid the inaccuracy
 problems that arose in problem 2 above (you can use your solution from
 problem 2).
 (In the event of a disaster, your method can fall back to an ordinary Newton
 step.)
\end_layout

\begin_layout Enumerate
Analyze its asymptotic convergence rate: if 
\begin_inset Formula $x$
\end_inset

 is an exact root, write 
\begin_inset Formula $x_{n}=x(1+\delta_{n})$
\end_inset

 as in class, and solve for 
\begin_inset Formula $\delta_{n+1}$
\end_inset

 in terms of 
\begin_inset Formula $\delta_{n}$
\end_inset

 assuming you are close to the root (
\begin_inset Formula $\delta_{n}\ll1$
\end_inset

).
\end_layout

\begin_layout Enumerate
Modify the Julia Newton's-method notebook from class to implement your method
 to compute a root of 
\begin_inset Formula $f(x)=x^{3}-1$
\end_inset

.
 In particular start with 
\begin_inset Formula $x_{1}=2$
\end_inset

, so that your scheme should(!) converge to 
\begin_inset Formula $x=1$
\end_inset

, and look at the error 
\begin_inset Formula $x_{n}-1$
\end_inset

.
 Demonstrate that it agrees with your predicted convergence rate from the
 previous part.
 [You should use arbitrary precision as in the notebook from class, so that
 you can watch the convergence rate for many digits.
 An approximate number of accurate digits is given by 
\begin_inset Formula $-\log_{10}(x_{n}-1)$
\end_inset

.]
\end_layout

\begin_layout Subsection*
Problem 4: Addition
\end_layout

\begin_layout Standard
This problem is about the floating-point error involved in summing 
\begin_inset Formula $n$
\end_inset

 numbers, i.e.
 in computing the function 
\begin_inset Formula $f(x)=\sum_{i=1}^{n}x_{i}$
\end_inset

 for 
\begin_inset Formula $x\in\mathbb{F}^{n}$
\end_inset

 (
\begin_inset Formula $\mathbb{F}$
\end_inset

 being the set of floating-point numbers), where the sum is done in the
 most obvious way, in sequence.
 In pseudocode:
\end_layout

\begin_layout LyX-Code
sum = 
\begin_inset Formula $0$
\end_inset


\end_layout

\begin_layout LyX-Code
for 
\begin_inset Formula $i$
\end_inset

 = 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset


\end_layout

\begin_layout LyX-Code
   sum = sum + 
\begin_inset Formula $x_{i}$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $f(x)$
\end_inset

 = sum
\end_layout

\begin_layout Standard
For analysis, it is a bit more convenient to define the process inductively:
 
\begin_inset Formula 
\begin{eqnarray*}
s_{0} & = & 0\\
s_{k} & = & s_{k-1}+x_{k}\;\mbox{for }0<k\leq n,
\end{eqnarray*}

\end_inset

with 
\begin_inset Formula $f(x)=s_{n}$
\end_inset

.
 When we implement this in floating-point, we get the function 
\begin_inset Formula $\tilde{f}(x)=\tilde{s}_{n}$
\end_inset

, where 
\begin_inset Formula $\tilde{s}_{k}=\tilde{s}_{k-1}\oplus x_{k}$
\end_inset

, with 
\begin_inset Formula $\oplus$
\end_inset

 denoting (correctly rounded) floating-point addition.
\end_layout

\begin_layout Enumerate
Show that 
\begin_inset Formula 
\[
\tilde{f}(x)=\sum_{i=1}^{n}x_{i}\prod_{k=i}^{n}(1+\epsilon_{k}),
\]

\end_inset

where 
\begin_inset Formula $\epsilon_{1}=0$
\end_inset

 and where the other 
\begin_inset Formula $\epsilon_{k}$
\end_inset

 satisfy 
\begin_inset Formula $|\epsilon_{k}|\leq\epsilon_{\mbox{machine}}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Show that the error can be bounded as: 
\begin_inset Formula $|\tilde{f}(x)-f(x)|\leq n\epsilon_{\mbox{machine}}\sum_{i=1}^{n}|x_{i}|+O(\epsilon_{\mbox{machine}}^{2})$
\end_inset

.
\end_layout

\begin_layout Enumerate
Suppose that the 
\begin_inset Formula $\epsilon_{\mbox{k}}$
\end_inset

 values are uniformly randomly distributed in 
\begin_inset Formula $[-\epsilon_{\mbox{machine}},+\epsilon_{\mbox{machine}}]$
\end_inset

.
 Explain why the 
\emph on
mean
\emph default
 error can be bounded by 
\begin_inset Formula $|\tilde{f}(x)-f(x)|=O\left(\sqrt{n}\epsilon_{\mbox{machine}}\sum_{i=1}^{n}|x_{i}|\right)$
\end_inset

.
 (Hint: google 
\begin_inset Quotes eld
\end_inset

random walk
\begin_inset Quotes erd
\end_inset

...you can just quote standard statistical results for random walks, no need
 to copy the proofs.) This explains the 
\begin_inset Quotes eld
\end_inset

my_cumsum
\begin_inset Quotes erd
\end_inset

 results shown in class.
\end_layout

\begin_layout Subsection*
Problem 5: Addition, another way
\end_layout

\begin_layout Standard
Here you will analyze 
\begin_inset Formula $f(x)=\sum_{i=1}^{n}x_{i}$
\end_inset

 as in problem
\begin_inset space ~
\end_inset

2, but this time you will compute 
\begin_inset Formula $\tilde{f}(x)$
\end_inset

 in a different way.
 In particular, compute 
\begin_inset Formula $\tilde{f}(x)$
\end_inset

 by a recursive divide-and-conquer approach, recursively dividing the set
 of values to be summed in two halves and then summing the halves: 
\begin_inset Formula 
\[
\tilde{f}(x)=\begin{cases}
0 & \mbox{if }n=0\\
x_{1} & \mbox{if }n=1\\
\tilde{f}(x_{1:\left\lfloor n/2\right\rfloor })\oplus\tilde{f}(x_{\left\lfloor n/2\right\rfloor +1:n}) & \mbox{if }n>1
\end{cases},
\]

\end_inset

where 
\begin_inset Formula $\left\lfloor y\right\rfloor $
\end_inset

 denotes the greatest integer 
\begin_inset Formula $\leq y$
\end_inset

 (i.e.
 
\begin_inset Formula $y$
\end_inset

 rounded down).
 In exact arithmetic, this computes 
\begin_inset Formula $f(x)$
\end_inset

 exactly, but in floating-point arithmetic this will have very different
 error characteristics than the simple loop-based summation in problem
\begin_inset space ~
\end_inset

2.
\end_layout

\begin_layout Enumerate
For simplicity, assume 
\begin_inset Formula $n$
\end_inset

 is a power of 2 (so that the set of numbers to add divides evenly in two
 at each stage of the recursion).
 With an analysis similar to that of problem
\begin_inset space ~
\end_inset

2, prove that 
\begin_inset Formula $|\tilde{f}(x)-f(x)|\leq\epsilon_{\mbox{machine}}\log_{2}(n)\sum_{i=1}^{n}|x_{i}|+O(\epsilon_{\mbox{machine}}^{2})$
\end_inset

.
 That is, show that the worst-case error bound grows 
\emph on
logarithmically
\emph default
 rather than 
\emph on
linearly
\emph default
 with 
\begin_inset Formula $n$
\end_inset

!
\end_layout

\begin_layout Enumerate
If the floating-point rounding errors are randomly distributed as in problem
 2, estimate the average-case error bound.
\end_layout

\begin_layout Enumerate
Pete R.
 Stunt, a Microsoft employee, complains, 
\begin_inset Quotes eld
\end_inset

While doing this kind of recursion may have nice error characteristics in
 theory, it is ridiculous in the real world because it will be insanely
 slow---I'm proud of my efficient software and can't afford to have a function-c
all overhead for every number I want to add!
\begin_inset Quotes erd
\end_inset

 Explain to Pete how to implement a slight variation of this algorithm with
 the same logarithmic error bounds (possibly with a worse constant factor)
 but roughly the same performance as a simple loop.
\end_layout

\begin_layout Enumerate
In the pset 1 Julia notebook, there is a function 
\begin_inset Quotes eld
\end_inset

div2sum
\begin_inset Quotes erd
\end_inset

 that computes 
\begin_inset Formula $\tilde{f}(x)=$
\end_inset


\family typewriter
div2sum(x)
\family default
 in single precision by the above algorithm.
 Modify it to not be horrendously slow via your suggestion in (c), and then
 plot its errors for random inputs as a function of 
\begin_inset Formula $n$
\end_inset

 with the help of the example code in the Julia notebook (but with a larger
 range of lengths 
\begin_inset Formula $n$
\end_inset

).
 Are your results consistent with your error estimates above?
\end_layout

\end_body
\end_document
